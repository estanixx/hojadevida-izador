name: AWS deploy workflow
on:
  workflow_dispatch: # Esto habilita el bot칩n manual
    inputs:
      reason:
        description: 'Raz칩n del despliegue manual'
        required: false
        default: 'Actualizaci칩n r치pida'
  push:
    branches:
      - prod
    paths:
      - 'frontend/**'
      - 'infrastructure/**'
env:
  ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_ARN }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
permissions:
  id-token: write
  contents: read
jobs:
  # 1. Create or update CloudFormation stack for network infrastructure (if changed)
  deploy-network-infrastructure:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }} # Adjust to your specific region

      - name: Deploy CloudFormation Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: my-network-infrastructure-stack
          template: infrastructure/network-setup.yaml
          capabilities: CAPABILITY_NAMED_IAM
          no-fail-on-empty-changeset: "true"

  # 3. Update frontend container definition and trigger ECS deployment (if changed)
  deploy-frontend:
    needs:  deploy-network-infrastructure
    runs-on: ubuntu-latest
    outputs:
      frontend_changed: ${{ steps.filter.outputs.frontend }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Detect frontend changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{env.ROLE_TO_ASSUME}}
          aws-region: ${{ env.AWS_REGION }} # Adjust to your specific region

      - name: Login to Amazon ECR
        id: login-ecr
        if: steps.filter.outputs.frontend == 'true'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, Tag, and Push Image to ECR
        if: steps.filter.outputs.frontend == 'true'
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-frontend-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Only build if frontend files changed (optional optimization)
          docker build -f ./frontend/Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
      
      - name: Get Current Image URI
        if: steps.filter.outputs.frontend == 'false'
        id: get-current
        run: |
          # Use AWS CLI to find the image currently in the Task Definition
          CURRENT_IMAGE=$(aws ecs describe-task-definition --task-definition hojadevida-frontend-task --query 'taskDefinition.containerDefinitions[0].image' --output text)
          echo "image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT

      - name: Deploy CloudFormation Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: my-frontend-stack
          template: infrastructure/frontend-setup.yaml
          parameter-overrides: >-
            ECRImageUri=${{ steps.build-image.outputs.image || steps.get-current.outputs.image }}
          capabilities: CAPABILITY_NAMED_IAM
          no-fail-on-empty-changeset: "true"